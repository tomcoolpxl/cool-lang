### Coolscript PEG Grammar Specification

This document defines the formal **Parsing Expression Grammar (PEG)** for Coolscript (`.cool`). Unlike context-free grammars (BNF), PEG is unambiguous and uses "ordered choice." This is particularly well-suited for Coolscript because it handles the Python-style indentation and the specific `move`/`view` call-site keywords without ambiguity.

---

## The Indentation Engine

Since Coolscript uses significant whitespace, the parser must track "Indentation Levels" using a stack.

* **NEWLINE**: Matches a physical newline followed by any number of spaces.
* **INDENT**: Generated when the space count increases compared to the stack top.
* **DEDENT**: Generated when the space count decreases; multiple DEDENTs are generated if the count drops across multiple levels.

---

## Formal Grammar (PEG)

```peg
# --- Top Level ---
Program         <- _ (Statement / TopLevelDecl)* _
TopLevelDecl    <- ProtocolDecl / StructDecl / EnumDecl / FunctionDecl / ImportDecl / ConstDecl

# --- Imports ---
ImportDecl      <- "import" _ String ( "as" _ Identifier )? NewLine

# --- Constants ---
ConstDecl       <- "const" _ Identifier _ ":" _ Type _ "=" _ Literal NewLine

# --- Type System ---
Type            <- ( "opt" / "Result" / "List" / "Dict" / "shared" ) "[" _ Type ( "," _ Type )* _ "]"
                 / "view" _ Identifier
                 / Identifier

# --- Structs and Protocols ---
StructDecl      <- "struct" _ Identifier ":" INDENT StructBody DEDENT
StructBody      <- ( (Identifier _ ":" _ Type) / FunctionDecl )+

ProtocolDecl    <- "protocol" _ Identifier ":" INDENT ProtocolBody DEDENT
ProtocolBody    <- ( "fn" _ Identifier "(" _ Params? _ ")" ( "->" _ Type )? )+

# --- Functions ---
FunctionDecl    <- "fn" _ Identifier "(" _ Params? _ ")" ( "->" _ Type )? ":" INDENT Block DEDENT
Params          <- Param ( "," _ Param )*
Param           <- ( "move" _ / "inout" _ )? Identifier _ ":" _ Type

# --- Control Flow ---
Block           <- ( Statement )+
Statement       <- IfStmt / WhileStmt / ForStmt / MatchStmt / LetStmt / ReturnStmt / ExprStmt

IfStmt          <- "if" _ Expression ":" INDENT Block DEDENT 
                   ( "elif" _ Expression ":" INDENT Block DEDENT )*
                   ( "else" ":" INDENT Block DEDENT )?

IfLetStmt       <- "if let" _ Identifier _ "=" _ Expression ":" INDENT Block DEDENT 
                   ( "else" ":" INDENT Block DEDENT )?

WhileStmt       <- "while" _ Expression ":" INDENT Block DEDENT

ForStmt         <- "for" _ Identifier _ "in" _ Expression ":" INDENT Block DEDENT

MatchStmt       <- "match" _ Expression ":" INDENT ( Case )+ DEDENT
Case            <- Identifier ( "(" _ Identifier _ ")" )? ":" INDENT Block DEDENT

# --- Expressions ---
Expression      <- TryExpr / TryPropagateExpr / LambdaExpr / LogicalExpr

# Postfix 'try' for Result types
TryExpr         <- LogicalExpr _ "try" ( "(" _ Identifier _ ")" )? ":" INDENT Block DEDENT

# Propagation operator '?'
TryPropagateExpr <- LogicalExpr _ "?"

# Lambda (Anonymous Function) - currently single expression body only for simplicity
LambdaExpr      <- "|" _ Params? _ "|" _ Expression

LogicalExpr     <- Equality ( ( "and" / "or" ) _ Equality )*
Equality        <- Comparison ( ( "==" / "!=" / "is" ) _ Comparison )*
Comparison      <- Term ( ( "<=" / ">=" / "<" / ">" ) _ Term )*

# Function Calls with explicit move/copy
CallExpr        <- Identifier "(" _ Arguments? _ ")"
Arguments       <- Argument ( "," _ Argument )*
Argument        <- ( "move" _ / "copy" _ / "inout" _ )? Expression

# --- Atoms ---
Term            <- Identifier / Literal / "(" _ Expression _ ")"
Identifier      <- [a-zA-Z_][a-zA-Z0-9_]*
Literal         <- FString / String / Float / Integer / Boolean / "None"
FString         <- 'f"' ( [^"{\n] / "{" Expression "}" )* '"'
String          <- '"' [^"]* '"' / "'" [^']* "'"

# --- Whitespace & Terminals ---
_               <- [ \t]* # Optional horizontal whitespace
NewLine         <- [ \t]* [\n\r]+          # Physical newline
INDENT          <- <generated by lexer>
DEDENT          <- <generated by lexer>

```

---

## Detailed Parser Logic

### Call-Site Dispatch

The `CallExpr` and `Argument` rules are critical. The PEG parser prioritizes the optional `move` or `copy` prefix. If neither is present, the compiler's semantic pass defaults to a `view`.

### The `try` Postfix

The `TryExpr` is defined as a high-level expression wrapper. Because PEG is greedy, the `try` will bind to the result of the preceding expression. This prevents the "Trailing Closure" ambiguity found in other languages.

### Optional Unwrapping (`if let`)

The `IfLetStmt` is a distinct syntactic construct. It explicitly requires an `Identifier` on the left and an `Expression` on the right. This prevents developers from accidentally using a standard `=` assignment (which moves ownership) inside a conditional.

---

## Semantic Analysis Rules (Post-Parsing)

Once the PEG parser builds the Abstract Syntax Tree (AST), the **Coolscript Semantic Analyzer** performs the following specific checks:

1. **Linearity Check**: For every `Identifier` used in a `move` Argument, the analyzer verifies that no subsequent references to that `Identifier` exist in the current scope.
2. **View Persistence**: The analyzer checks every `Type` marked as `view`. If a `view` type appears inside a `StructBody` definition, it throws a **"No-Escape Violation"** error.
3. **Exhaustiveness**: For every `MatchStmt`, the analyzer retrieves the definition of the `Enum` or `Protocol` and ensures every variant or known implementer is handled.

---

## MLIR Lowering Strategy

Coolscript lowers this grammar into a custom MLIR Dialect (`cool`).

| PEG Construct | MLIR Operation | Resulting Behavior |
| --- | --- | --- |
| `move x` | `cool.move %x` | Invalidates the SSA value for `%x` in the IR. |
| `view x` | `cool.borrow %x` | Passes a pointer with a scoped lifetime attribute. |
| `spawn func()` | `cool.task_spawn @func` | Allocates a fixed-stack isolate and transfers owned registers. |

